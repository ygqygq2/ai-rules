---
id: 701
title: Web 应用安全最佳实践
description: Web 应用安全防护、漏洞防范和安全编码的最佳实践
globs: ["**/*.js", "**/*.ts", "**/*.py", "src/**/*", "app/**/*"]
priority: medium
tags: [security, web-security, owasp, xss, csrf, sql-injection]
version: 1.0.0
author: Turbo AI Rules
lastUpdated: 2025-11-20
---

# Web 应用安全最佳实践

## 适用场景

- Web 应用安全开发
- API 安全防护
- 身份认证和授权
- 数据保护
- 安全编码实践
- 漏洞防范

## 核心内容

Web 应用安全的核心最佳实践，涵盖 OWASP Top 10 漏洞防范、身份认证、数据加密、输入验证等方面。

## 关键原则

- ✅ 永远不要信任用户输入
- ✅ 使用参数化查询防止 SQL 注入
- ✅ 实施适当的身份认证和授权
- ✅ 加密敏感数据
- ✅ 使用 HTTPS
- ✅ 实施安全头部
- ✅ 定期更新依赖

## SQL 注入防护

- 使用参数化查询或 ORM
- 永不拼接 SQL 语句
- 使用白名单验证输入
- 限制数据库权限
- 使用预编译语句
- 输入验证和转义

**SQL 注入防护示例：**

```javascript
// ❌ 危险 - SQL 注入
const query = `SELECT * FROM users WHERE username = '${username}'`;

// ✅ 安全 - 参数化查询
const query = 'SELECT * FROM users WHERE username = ?';
db.query(query, [username]);

// ✅ 使用 ORM
const user = await User.findOne({ where: { username } });

// Python 示例
# ❌ 危险
cursor.execute(f"SELECT * FROM users WHERE username = '{username}'")

# ✅ 安全
cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
```

## XSS 防护

- 转义所有用户输入
- 使用 Content Security Policy
- 使用 HTTP-only Cookie
- 验证和净化 HTML
- 使用模板引擎自动转义
- 避免使用 dangerouslySetInnerHTML

**XSS 防护示例：**

```javascript
// ❌ 危险 - XSS 漏洞
document.innerHTML = userInput;

// ✅ 安全 - 转义输出
const escapeHtml = (str) => {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
};
document.textContent = escapeHtml(userInput);

// React 自动转义
return <div>{userInput}</div>;

// CSP 头部
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'
```

## CSRF 防护

- 使用 CSRF Token
- 验证请求来源
- 使用 SameSite Cookie
- 双重提交 Cookie
- 检查 Referer 头部
- 使用 POST 进行状态改变

**CSRF 防护示例：**

```javascript
// Express.js CSRF 防护
const csrf = require("csurf");
const csrfProtection = csrf({ cookie: true });

app.use(csrfProtection);

app.get("/form", (req, res) => {
  res.render("form", { csrfToken: req.csrfToken() });
});

app.post("/process", csrfProtection, (req, res) => {
  // 处理表单
});

// SameSite Cookie
res.cookie("token", value, {
  httpOnly: true,
  secure: true,
  sameSite: "strict",
});
```

## 身份认证

- 使用强密码策略
- 密码加密存储（bcrypt）
- 实施多因素认证
- 使用 JWT 或 Session
- 限制登录尝试
- 使用安全的密码重置流程

**身份认证示例：**

```javascript
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");

// 注册 - 密码加密
const hashPassword = async (password) => {
  const salt = await bcrypt.genSalt(10);
  return await bcrypt.hash(password, salt);
};

const user = await User.create({
  email: req.body.email,
  password: await hashPassword(req.body.password),
});

// 登录 - 密码验证
const isValidPassword = await bcrypt.compare(req.body.password, user.password);

if (!isValidPassword) {
  return res.status(401).json({ error: "Invalid credentials" });
}

// 生成 JWT
const token = jwt.sign({ userId: user.id, email: user.email }, process.env.JWT_SECRET, { expiresIn: "24h" });

// 验证 JWT
const authenticate = (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: "Invalid token" });
  }
};
```

## 授权控制

- 实施基于角色的访问控制（RBAC）
- 验证资源所有权
- 使用最小权限原则
- 检查每个请求的权限
- 避免不安全的直接对象引用
- 记录授权失败

**授权控制示例：**

```javascript
// 基于角色的访问控制
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Forbidden" });
    }

    next();
  };
};

// 使用
app.delete("/api/users/:id", authenticate, authorize("admin"), deleteUser);

// 资源所有权检查
app.put("/api/posts/:id", authenticate, async (req, res) => {
  const post = await Post.findById(req.params.id);

  if (!post) {
    return res.status(404).json({ error: "Not found" });
  }

  if (post.authorId !== req.user.id && req.user.role !== "admin") {
    return res.status(403).json({ error: "Forbidden" });
  }

  // 更新文章
});
```

## 输入验证

- 验证所有用户输入
- 使用白名单而非黑名单
- 验证数据类型和格式
- 限制输入长度
- 使用验证库（Joi、Yup）
- 服务端验证不可省略

**输入验证示例：**

```javascript
const Joi = require("joi");

// 定义验证 schema
const userSchema = Joi.object({
  username: Joi.string().alphanum().min(3).max(30).required(),
  email: Joi.string().email().required(),
  password: Joi.string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
    .required(),
  age: Joi.number().integer().min(18).max(120),
});

// 验证中间件
const validate = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);

    if (error) {
      return res.status(400).json({
        error: "Validation failed",
        details: error.details.map((d) => d.message),
      });
    }

    next();
  };
};

// 使用
app.post("/api/users", validate(userSchema), createUser);
```

## 数据加密

- 使用 HTTPS 传输数据
- 加密敏感数据存储
- 使用环境变量存储密钥
- 使用安全的加密算法
- 定期更换密钥
- 不在代码中硬编码密钥

**数据加密示例：**

```javascript
const crypto = require("crypto");

// 加密敏感数据
const encrypt = (text) => {
  const algorithm = "aes-256-gcm";
  const key = Buffer.from(process.env.ENCRYPTION_KEY, "hex");
  const iv = crypto.randomBytes(16);

  const cipher = crypto.createCipheriv(algorithm, key, iv);
  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");

  const authTag = cipher.getAuthTag();

  return {
    encrypted,
    iv: iv.toString("hex"),
    authTag: authTag.toString("hex"),
  };
};

// 解密数据
const decrypt = (encrypted, iv, authTag) => {
  const algorithm = "aes-256-gcm";
  const key = Buffer.from(process.env.ENCRYPTION_KEY, "hex");

  const decipher = crypto.createDecipheriv(algorithm, key, Buffer.from(iv, "hex"));

  decipher.setAuthTag(Buffer.from(authTag, "hex"));

  let decrypted = decipher.update(encrypted, "hex", "utf8");
  decrypted += decipher.final("utf8");

  return decrypted;
};
```

## 安全头部

- 设置安全相关的 HTTP 头部
- 使用 Helmet.js（Node.js）
- 配置 CSP
- 禁用 X-Powered-By
- 设置 HSTS
- 设置 X-Frame-Options

**安全头部示例：**

```javascript
const helmet = require("helmet");

app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
  })
);

// 手动设置头部
app.use((req, res, next) => {
  res.setHeader("X-Content-Type-Options", "nosniff");
  res.setHeader("X-Frame-Options", "DENY");
  res.setHeader("X-XSS-Protection", "1; mode=block");
  res.removeHeader("X-Powered-By");
  next();
});
```

## 速率限制

- 防止暴力破解
- 限制 API 请求频率
- 使用滑动窗口算法
- 针对不同端点设置不同限制
- 记录异常请求
- 返回适当的错误信息

**速率限制示例：**

```javascript
const rateLimit = require("express-rate-limit");

// API 速率限制
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 分钟
  max: 100, // 最多 100 个请求
  message: "Too many requests, please try again later",
});

app.use("/api/", apiLimiter);

// 登录速率限制
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 15 分钟内最多 5 次尝试
  skipSuccessfulRequests: true,
});

app.post("/api/login", loginLimiter, login);
```

## 依赖安全

- 定期更新依赖
- 使用 npm audit 检查漏洞
- 使用 Snyk 或 Dependabot
- 锁定依赖版本
- 审查新依赖
- 移除未使用的依赖

**依赖安全检查：**

```bash
# 检查漏洞
npm audit

# 自动修复
npm audit fix

# 查看依赖树
npm ls
```

## 日志和监控

- 记录安全事件
- 不记录敏感信息
- 监控异常活动
- 设置告警机制
- 定期审查日志
- 使用集中日志系统

**安全日志示例：**

```javascript
const logger = require("./logger");

// 记录安全事件
const logSecurityEvent = (event, user, details) => {
  logger.warn("Security Event", {
    event,
    userId: user?.id,
    ip: details.ip,
    userAgent: details.userAgent,
    timestamp: new Date(),
  });
};

// 使用
app.post("/api/login", async (req, res) => {
  const user = await authenticate(req.body);

  if (!user) {
    logSecurityEvent("LOGIN_FAILED", null, {
      ip: req.ip,
      userAgent: req.headers["user-agent"],
      email: req.body.email,
    });
    return res.status(401).json({ error: "Invalid credentials" });
  }

  logSecurityEvent("LOGIN_SUCCESS", user, {
    ip: req.ip,
    userAgent: req.headers["user-agent"],
  });
});
```

## 工具配置

**推荐工具：**

- Helmet.js（安全头部）
- express-rate-limit（速率限制）
- Joi/Yup（输入验证）
- bcrypt（密码加密）
- OWASP ZAP（安全扫描）

## 常见问题

**Q: 如何安全存储密码？**
A: 使用 bcrypt 等慢速哈希算法，加盐存储，永不明文。

**Q: JWT 应该存储在哪里？**
A: 使用 HTTP-only Cookie，避免存储在 localStorage。

## 扩展阅读

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)
- [Web Security Academy](https://portswigger.net/web-security)
- [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security)
