---
id: 202
title: Next.js Best Practices
description: Next.js 14+ App Router 开发规范（SSR/SSG/Server Components）
globs: ["app/**/*", "pages/**/*", "next.config.{js,ts}"]
priority: medium
tags: [nextjs, react, ssr, app-router, server-components]
version: 1.0.0
author: ygqygq2
lastUpdated: 2025-12-26
---

# Next.js Best Practices

## 适用场景

- Next.js 14+ App Router（非 Pages Router）
- 服务端渲染（SSR）/静态生成（SSG）
- React 全栈应用、SEO 优化

## 核心内容

App Router 架构、Server/Client Components 分离、数据获取缓存、路由设计、性能优化。

## 关键原则

✅ 默认 Server Components，需交互才 'use client'  
✅ 文件系统路由（page.tsx/layout.tsx/error.tsx/loading.tsx）  
✅ fetch 缓存：`{ next: { revalidate: 3600 } }` 或 `{ cache: 'no-store' }`  
✅ next/image + next/font 优化资源  
✅ Promise.all() 并行数据获取，避免瀑布  
✅ Suspense + loading.tsx 处理加载状态

## 项目结构

```
app/
├── (auth)/              # 路由组（不影响 URL）
│   ├── login/page.tsx
│   └── register/page.tsx
├── (dashboard)/
│   ├── layout.tsx
│   └── page.tsx
├── api/users/route.ts   # API 路由
├── components/          # 共享组件
├── lib/                 # 工具函数
├── layout.tsx           # 根布局
├── page.tsx             # 首页
└── globals.css
```

## 关键决策点

### 1. Server vs Client Components

**何时:** 组件设计时  
**为什么:** 减少客户端 JS，提升性能

```tsx
// ✅ Server Component（默认）- 数据获取/静态内容
async function UsersPage() {
  const users = await fetch("...").then((r) => r.json());
  return <UserList users={users} />;
}

// ✅ Client Component - 交互/状态/浏览器 API
("use client");
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

### 2. 数据获取与缓存

**何时:** 服务端组件中获取数据  
**为什么:** 控制缓存策略，优化性能

```tsx
// 静态数据（默认缓存）
const res = await fetch("https://api.example.com/posts");

// 动态数据（不缓存）
const res = await fetch("https://api.example.com/posts", {
  cache: "no-store",
});

// ISR（定时重新验证）
const res = await fetch("https://api.example.com/posts", {
  next: { revalidate: 3600 }, // 每小时
});

// 并行请求（避免瀑布）
const [product, reviews] = await Promise.all([getProduct(id), getReviews(id)]);
```

### 3. 路由设计

**何时:** 文件系统路由  
**为什么:** 约定优于配置

```
app/
├── page.tsx              → /
├── about/page.tsx        → /about
├── blog/
│   ├── page.tsx          → /blog
│   └── [slug]/page.tsx   → /blog/:slug (动态)
├── (marketing)/          → 路由组（不影响 URL）
│   └── pricing/page.tsx  → /pricing
└── api/users/route.ts    → /api/users (API 路由)
```

```tsx
// 动态路由 + generateStaticParams
export async function generateStaticParams() {
  const posts = await getAllPosts();
  return posts.map((p) => ({ slug: p.slug }));
}

export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug);
  return <Article post={post} />;
}
```

### 4. 加载与错误处理

**何时:** 每个路由段  
**为什么:** 提升用户体验

```tsx
// loading.tsx（自动包裹 Suspense）
export default function Loading() {
  return <Skeleton />;
}

// error.tsx（错误边界）
("use client");
export default function Error({ error, reset }: { error: Error; reset: () => void }) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={reset}>Try again</button>
    </div>
  );
}

// Suspense 精细控制
import { Suspense } from "react";

export default function Page() {
  return (
    <>
      <Suspense fallback={<ChartSkeleton />}>
        <Analytics />
      </Suspense>
      <Suspense fallback={<OrdersSkeleton />}>
        <RecentOrders />
      </Suspense>
    </>
  );
}
```

### 5. 图片与字体优化

**何时:** 加载图片和字体  
**为什么:** 自动优化，提升性能

```tsx
import Image from "next/image";
import { Inter } from "next/font/google";

// 图片优化
<Image
  src="/hero.jpg"
  alt="Hero"
  width={800}
  height={600}
  priority // 预加载关键图片
  placeholder="blur"
/>;

// 字体优化
const inter = Inter({ subsets: ["latin"], variable: "--font-inter" });

export default function RootLayout({ children }) {
  return (
    <html className={inter.variable}>
      <body>{children}</body>
    </html>
  );
}
```

### 6. Server Actions（表单处理）

**何时:** 表单提交/数据变更  
**为什么:** 无需 API 路由，直接服务端执行

```tsx
// app/actions.ts
"use server";
import { revalidatePath } from "next/cache";
import { z } from "zod";

const schema = z.object({
  title: z.string().min(1),
  content: z.string().min(1),
});

export async function createPost(formData: FormData) {
  const result = schema.safeParse({
    title: formData.get("title"),
    content: formData.get("content"),
  });

  if (!result.success) {
    return { error: result.error.flatten() };
  }

  await db.post.create({ data: result.data });
  revalidatePath("/posts");
  return { success: true };
}

// 使用
<form action={createPost}>
  <input name="title" />
  <textarea name="content" />
  <button type="submit">Create</button>
</form>;
```

### 7. 认证（NextAuth.js）

**何时:** 需要用户认证  
**为什么:** 官方推荐方案

```tsx
// app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth";
import GithubProvider from "next-auth/providers/github";

export const authOptions = {
  providers: [
    GithubProvider({
      clientId: process.env.GITHUB_ID!,
      clientSecret: process.env.GITHUB_SECRET!,
    }),
  ],
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

// 服务端组件使用
import { getServerSession } from "next-auth";

async function ProfilePage() {
  const session = await getServerSession(authOptions);
  if (!session) redirect("/login");
  return <Profile user={session.user} />;
}

// 客户端组件使用
("use client");
import { useSession } from "next-auth/react";

function UserMenu() {
  const { data: session } = useSession();
  if (!session) return <LoginButton />;
  return <UserDropdown user={session.user} />;
}
```

## 项目特定配置

### next.config.ts

```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    domains: ["cdn.example.com"],
    formats: ["image/webp", "image/avif"],
  },
  experimental: {
    serverActions: true,
  },
};

export default nextConfig;
```

### 环境变量

```bash
# .env.local
DATABASE_URL="postgresql://..."         # 仅服务端
NEXT_PUBLIC_API_URL="https://api..."    # 客户端可访问（NEXT_PUBLIC_前缀）
```

```tsx
// 使用 Zod 验证
import { z } from "zod";

const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NEXT_PUBLIC_API_URL: z.string().url(),
});

export const env = envSchema.parse(process.env);
```

### Middleware（路由保护）

```ts
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  const token = request.cookies.get("token");

  if (request.nextUrl.pathname.startsWith("/dashboard") && !token) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/dashboard/:path*", "/admin/:path*"],
};
```

## 常见问题

**Q: 何时用 Server vs Client Component?**  
A: 默认 Server，需要 useState/useEffect/事件处理才用 Client

**Q: 如何优化首屏加载?**  
A: Server Components + next/image + 代码分割 + Suspense

**Q: 如何处理表单?**  
A: Server Actions（推荐）或 API 路由

## 扩展阅读

- [Next.js App Router 文档](https://nextjs.org/docs/app)
- [Data Fetching 指南](https://nextjs.org/docs/app/building-your-application/data-fetching)
- [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
