---
id: 271
title: Next.js + TypeScript + Tailwind CSS 组合最佳实践
description: Next.js App Router、TypeScript 和 Tailwind CSS 组合使用时的特定集成模式
globs: ["app/**/*.tsx", "app/**/*.ts", "next.config.ts", "tailwind.config.ts"]
priority: high
tags: [nextjs, typescript, tailwindcss, app-router, combination, full-stack]
version: 1.0.0
author: Turbo AI Rules
lastUpdated: 2025-11-20
---

# Next.js + TypeScript + Tailwind CSS 组合最佳实践

## 适用场景

本规则仅涵盖三个技术栈**组合使用时的特定集成模式**。

- 服务端组件的类型安全样式
- API 路由的类型化和验证
- 全栈类型安全开发

## 关键原则

- ✅ 服务端组件：类型化 props + Metadata + Tailwind 响应式
- ✅ API 路由：Zod schema 验证 + 类型推断
- ✅ 客户端/服务端共享 Zod schema
- ✅ TypeScript 路径别名 + Tailwind 配置对齐

## TypeScript 路径别名配置

```json
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./*"],
      "@/components/*": ["./components/*"],
      "@/lib/*": ["./lib/*"]
    }
  }
}
```

## 类型安全的服务端组件 + Tailwind

```tsx
// app/users/page.tsx
import { type Metadata } from "next";

interface User {
  id: string;
  name: string;
  email: string;
}
interface UsersPageProps {
  searchParams: { page?: string };
}

export const metadata: Metadata = {
  title: "Users",
};

async function getUsers(page: number = 1): Promise<User[]> {
  const res = await fetch(`https://api.example.com/users?page=${page}`, {
    next: { revalidate: 3600 },
  });
  if (!res.ok) throw new Error("Failed to fetch users");
  return res.json();
}

export default async function UsersPage({ searchParams }: UsersPageProps) {
  const page = Number(searchParams.page) || 1;
  const users = await getUsers(page);

  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-6">Users</h1>
      <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
        {users.map((user) => (
          <UserCard key={user.id} user={user} />
        ))}
      </div>
    </div>
  );
}
```

**关键集成点：**

- `Metadata` 类型确保 SEO 元数据安全
- `searchParams` 类型化页面参数
- Tailwind 响应式网格

## 类型安全的 API 路由 + Zod

```tsx
// app/api/users/route.ts
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";

const createUserSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().int().positive(),
});

type CreateUserInput = z.infer<typeof createUserSchema>;

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validatedData = createUserSchema.parse(body); // 运行时验证 + 类型推断
    const user = await createUser(validatedData);
    return NextResponse.json(user, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: "Validation failed", details: error.errors }, { status: 400 });
    }
    return NextResponse.json({ error: "Failed to create user" }, { status: 500 });
  }
}
```

## 客户端类型化表单 + Tailwind

```tsx
// components/user-form.tsx
"use client";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { z } from "zod";

const userSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().int().positive(),
});

type UserFormData = z.infer<typeof userSchema>;

export function UserForm({ onSuccess }: { onSuccess?: () => void }) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setErrors({});

    const formData = new FormData(e.currentTarget);
    const data = {
      name: formData.get("name") as string,
      email: formData.get("email") as string,
      age: Number(formData.get("age")),
    };

    try {
      const validatedData = userSchema.parse(data);
      const response = await fetch("/api/users", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(validatedData),
      });
      if (!response.ok) throw new Error("Failed to create user");
      router.refresh();
      onSuccess?.();
    } catch (error) {
      if (error instanceof z.ZodError) {
        const fieldErrors: Record<string, string> = {};
        error.errors.forEach((err) => {
          if (err.path[0]) fieldErrors[err.path[0] as string] = err.message;
        });
        setErrors(fieldErrors);
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Input name="name" label="Name" error={errors.name} />
      <Input name="email" type="email" label="Email" error={errors.email} />
      <Input name="age" type="number" label="Age" error={errors.age} />
      <Button type="submit" isLoading={isLoading}>
        Create User
      </Button>
    </form>
  );
}
```

**集成要点：**

- 客户端和服务端使用相同 Zod schema
- Next.js useRouter 刷新服务端数据
- Tailwind 表单样式

## Next.js + CVA 组件库

```tsx
// components/ui/button.tsx
import { forwardRef } from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva("inline-flex items-center justify-center rounded-lg font-medium transition-all", {
  variants: {
    variant: {
      primary: "bg-blue-600 text-white hover:bg-blue-700",
      secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300",
    },
    size: {
      sm: "h-9 px-3 text-sm",
      md: "h-10 px-4",
    },
  },
  defaultVariants: { variant: "primary", size: "md" },
});

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  isLoading?: boolean;
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, isLoading, children, disabled, ...props }, ref) => {
    return (
      <button
        ref={ref}
        className={cn(buttonVariants({ variant, size, className }))}
        disabled={disabled || isLoading}
        {...props}
      >
        {isLoading && <LoadingSpinner />}
        {children}
      </button>
    );
  }
);

Button.displayName = "Button";
```

## 常见集成问题

**Q: 如何在客户端和服务端共享类型？**
A: 使用 Zod schema 同时提供类型推断和验证，放在 `lib/validators.ts`。

**Q: TypeScript 路径别名在 Tailwind 配置中如何使用？**
A: Tailwind 配置使用相对路径，不支持 TypeScript 路径别名。

## 扩展阅读

- [Next.js TypeScript 文档](https://nextjs.org/docs/app/building-your-application/configuring/typescript)
- [Zod 验证库](https://zod.dev/)
