---
id: 901
title: 微服务架构最佳实践
description: 微服务架构设计、实现和治理的最佳实践
globs: ["**/services/**/*", "**/microservices/**/*", "**/*service*.js", "**/*service*.ts"]
priority: medium
tags: [microservices, architecture, distributed-systems, api-gateway, service-mesh]
version: 1.0.0
author: Turbo AI Rules
lastUpdated: 2025-11-20
---

# 微服务架构最佳实践

## 适用场景

- 微服务架构设计、分布式系统开发、云原生应用

## 核心内容

服务拆分策略、通信模式（同步/异步）、Saga 分布式事务、服务发现、熔断降级、可观测性。

## 关键原则

- ✅ 单一职责原则
- ✅ 服务自治和独立部署
- ✅ 去中心化数据管理
- ✅ 面向失败设计
- ✅ 可观测性优先

## 关键决策点

### 1. 服务拆分边界

```
✅ 合理拆分（按业务能力）
- 用户服务、订单服务、支付服务、库存服务

❌ 过度拆分
- 用户基本信息服务、用户地址服务（应合并入用户服务）
```

### 2. Saga 模式处理分布式事务

```javascript
class OrderSaga {
  async createOrder(orderData) {
    const sagaId = generateId();
    try {
      const order = await orderService.create(orderData);
      await inventoryService.reserve(order.items, sagaId);
      await paymentService.charge(order.totalAmount, sagaId);
      return await orderService.confirm(order.id);
    } catch (error) {
      // 补偿事务
      await paymentService.refund(sagaId);
      await inventoryService.release(sagaId);
      await orderService.cancel(sagaId);
      throw error;
    }
  }
}
```

### 3. 熔断器防止级联故障

```javascript
const CircuitBreaker = require("opossum");

const breaker = new CircuitBreaker(fetchProduct, {
  timeout: 3000,
  errorThresholdPercentage: 50,
  resetTimeout: 30000,
});

breaker.fallback(() => ({ name: "Product unavailable" }));
const product = await breaker.fire(productId);
```

### 4. 分布式追踪

```javascript
const tracer = initTracer({ serviceName: "order-service" });

app.get("/api/orders/:id", async (req, res) => {
  const span = tracer.startSpan("get_order");
  const productSpan = tracer.startSpan("fetch_product", { childOf: span });
  const product = await productService.getProduct(order.productId);
  productSpan.finish();
  span.finish();
  res.json({ order, product });
});
```

### 5. Kubernetes 部署和自动扩缩容

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  replicas: 3
  template:
    spec:
      containers:
        - name: product-service
          image: product-service:v1.0.0
          resources:
            requests: { memory: "256Mi", cpu: "250m" }
          livenessProbe:
            httpGet: { path: /health, port: 3000 }
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
spec:
  scaleTargetRef: { kind: Deployment, name: product-service }
  minReplicas: 3
  maxReplicas: 10
  metrics:
    - type: Resource
      resource: { name: cpu, target: { type: Utilization, averageUtilization: 70 } }
```

## 项目特定配置

工具栈: Kubernetes、Consul/Eureka、Kong/Nginx、Prometheus + Grafana、Jaeger

## 常见问题

**Q: 如何处理分布式事务？**
A: 使用 Saga 模式或事件溯源实现最终一致性。

**Q: 如何拆分单体应用？**
A: 按业务能力逐步拆分,使用 Strangler Fig 模式。

## 扩展阅读

- [Microservices Patterns](https://microservices.io/patterns/)
- [The Twelve-Factor App](https://12factor.net/)
