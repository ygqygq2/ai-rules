---
id: 304
title: MySQL 性能优化
description: MySQL 查询性能优化、索引优化、配置调优和监控实践
globs: ['**/*.sql', '**/*mysql*.{js,ts,py,go}', 'my.cnf', 'my.ini']
priority: medium
tags: [mysql, performance, optimization, monitoring, slow-query]
version: 1.0.0
author: Turbo AI Rules
lastUpdated: 2026-01-23
---

# MySQL 性能优化

## 适用场景

- MySQL 8.0+ 性能调优
- 慢查询优化
- 索引设计和优化
- 数据库监控和诊断
- 高并发场景优化

## 关键原则

- ✅ 使用 EXPLAIN 分析查询执行计划
- ✅ 慢查询日志识别性能瓶颈
- ✅ 索引优化：避免全表扫描、利用覆盖索引
- ✅ 查询重写：避免子查询、优化 JOIN
- ✅ 配置优化：缓冲池、连接数、临时表
- ✅ 监控关键指标：QPS、TPS、慢查询数、连接数

## EXPLAIN 执行计划分析

```sql
EXPLAIN SELECT u.username, COUNT(p.id) as post_count
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
WHERE u.is_active = TRUE
GROUP BY u.id, u.username;
```

**关键字段解读：**

| 字段            | 说明           | 优化目标                                            |
| --------------- | -------------- | --------------------------------------------------- |
| `type`          | 访问类型       | system > const > eq_ref > ref > range > index > ALL |
| `possible_keys` | 可能使用的索引 | -                                                   |
| `key`           | 实际使用的索引 | 不为 NULL                                           |
| `rows`          | 扫描的行数     | 越少越好                                            |
| `Extra`         | 额外信息       | Using index（覆盖索引）最优                         |

**type 类型优先级：**

- ✅ `const`：主键或唯一索引查询
- ✅ `eq_ref`：唯一索引 JOIN
- ✅ `ref`：非唯一索引查询
- ⚠️ `range`：范围查询（WHERE id > 100）
- ❌ `index`：索引全扫描
- ❌ `ALL`：全表扫描（必须优化）

**Extra 关键信息：**

- ✅ `Using index`：覆盖索引（无需回表）
- ✅ `Using index condition`：索引下推
- ⚠️ `Using where`：需要过滤
- ⚠️ `Using temporary`：使用临时表
- ❌ `Using filesort`：文件排序（需优化）

## 索引优化策略

### 1. 复合索引最左前缀原则

```sql
-- 创建复合索引
CREATE INDEX idx_user_status_created ON posts(user_id, status, created_at);

-- ✅ 可以使用索引
SELECT * FROM posts WHERE user_id = 1;
SELECT * FROM posts WHERE user_id = 1 AND status = 'published';
SELECT * FROM posts WHERE user_id = 1 AND status = 'published' AND created_at > '2026-01-01';

-- ❌ 无法使用索引（跳过了最左列）
SELECT * FROM posts WHERE status = 'published';
SELECT * FROM posts WHERE created_at > '2026-01-01';
```

### 2. 覆盖索引避免回表

```sql
-- 查询需要 id, user_id, status, created_at
CREATE INDEX idx_posts_cover ON posts(user_id, status, created_at);

-- ✅ 使用覆盖索引（不需要回表查主键）
SELECT user_id, status, created_at
FROM posts
WHERE user_id = 1 AND status = 'published';
```

### 3. 索引选择性

```sql
-- ✅ 高选择性字段适合建索引
-- email, username, phone（值基本唯一）
CREATE INDEX idx_users_email ON users(email);

-- ❌ 低选择性字段不建议独立索引
-- gender(男/女/未知), status(2-3个状态)
-- 可作为复合索引的第二列
CREATE INDEX idx_users_status_created ON users(status, created_at);
```

## 慢查询优化

### 启用慢查询日志

```sql
-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 设置慢查询阈值（秒）
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 超过1秒记录
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';
```

### 分析慢查询日志

```bash
# 使用 mysqldumpslow 分析
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

# 参数说明：
# -s t: 按查询时间排序
# -t 10: 显示前 10 条
# -g pattern: 正则匹配
```

### 常见慢查询优化

```sql
-- ❌ 避免：子查询（MySQL 5.6 前性能差）
SELECT * FROM posts
WHERE user_id IN (SELECT id FROM users WHERE is_active = TRUE);

-- ✅ 改进：JOIN
SELECT p.* FROM posts p
INNER JOIN users u ON p.user_id = u.id
WHERE u.is_active = TRUE;

-- ❌ 避免：OFFSET 大偏移量分页
SELECT * FROM posts ORDER BY id LIMIT 100000, 20;

-- ✅ 改进：使用 WHERE 替代 OFFSET
SELECT * FROM posts WHERE id > 100000 ORDER BY id LIMIT 20;

-- ❌ 避免：隐式类型转换
SELECT * FROM users WHERE id = '123';  -- id 是 INT，传入 STRING

-- ✅ 改进：类型匹配
SELECT * FROM users WHERE id = 123;
```

## 查询重写技巧

### 1. COUNT(\*) 优化

```sql
-- ❌ 慢：大表全表扫描
SELECT COUNT(*) FROM posts;

-- ✅ 快：利用索引（InnoDB 辅助索引更小）
SELECT COUNT(*) FROM posts WHERE created_at IS NOT NULL;  -- 假设 created_at 有索引

-- ✅ 快：近似值（大表使用）
EXPLAIN SELECT * FROM posts;  -- 查看 rows 字段（估算值）
```

### 2. 分页优化

```sql
-- ❌ 深分页性能差
SELECT * FROM posts ORDER BY id LIMIT 100000, 20;

-- ✅ 延迟关联（先查索引再关联）
SELECT p.* FROM posts p
INNER JOIN (
    SELECT id FROM posts ORDER BY id LIMIT 100000, 20
) AS tmp ON p.id = tmp.id;

-- ✅ 基于上次结果（推荐）
SELECT * FROM posts WHERE id > 100000 ORDER BY id LIMIT 20;
```

### 3. IN vs EXISTS

```sql
-- 外表小、内表大：使用 IN
SELECT * FROM users WHERE id IN (SELECT user_id FROM posts);

-- 外表大、内表小：使用 EXISTS
SELECT * FROM posts p WHERE EXISTS (
    SELECT 1 FROM users u WHERE u.id = p.user_id AND u.is_active = TRUE
);
```

## my.cnf 配置优化

```ini
[mysqld]
# === 基础配置 ===
port = 3306
datadir = /var/lib/mysql
socket = /var/lib/mysql/mysql.sock

# === 字符集 ===
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci

# === InnoDB 缓冲池（最重要）===
# 建议设置为物理内存的 50%-70%（专用数据库服务器）
innodb_buffer_pool_size = 4G
innodb_buffer_pool_instances = 4  # 多实例减少竞争（1G = 1 instance）

# === InnoDB 日志 ===
innodb_log_file_size = 512M  # 减少刷盘频率
innodb_log_buffer_size = 16M
innodb_flush_log_at_trx_commit = 2  # 性能优先（1=最安全但慢）

# === 连接配置 ===
max_connections = 500  # 根据应用并发调整
max_connect_errors = 100000
back_log = 512

# === 查询缓存（MySQL 8.0 已移除）===
# 不再需要配置

# === 临时表 ===
tmp_table_size = 64M
max_heap_table_size = 64M

# === 排序和连接 ===
sort_buffer_size = 2M  # 每个连接独立分配，不宜过大
join_buffer_size = 2M
read_rnd_buffer_size = 2M

# === 慢查询日志 ===
slow_query_log = ON
long_query_time = 1
slow_query_log_file = /var/log/mysql/slow.log
log_queries_not_using_indexes = ON

# === 二进制日志（主从复制）===
log_bin = /var/log/mysql/mysql-bin.log
binlog_format = ROW
expire_logs_days = 7
max_binlog_size = 100M

# === 线程池（MySQL Enterprise 或 Percona）===
# thread_handling = pool-of-threads
# thread_pool_size = 16
```

**配置原则：**

- `innodb_buffer_pool_size`：最关键参数，越大越好（不超过物理内存 70%）
- `max_connections`：根据实际并发连接数设置，过大浪费内存
- `innodb_flush_log_at_trx_commit = 2`：性能优先，可容忍极端情况丢失1秒数据
- `innodb_flush_log_at_trx_commit = 1`：数据安全优先（银行、金融）

## 监控关键指标

```sql
-- 查看连接数
SHOW STATUS LIKE 'Threads_connected';
SHOW STATUS LIKE 'Max_used_connections';

-- QPS（每秒查询数）
SHOW GLOBAL STATUS LIKE 'Questions';

-- TPS（每秒事务数）
SHOW GLOBAL STATUS LIKE 'Com_commit';
SHOW GLOBAL STATUS LIKE 'Com_rollback';

-- 缓冲池命中率（应 > 99%）
SHOW STATUS LIKE 'Innodb_buffer_pool_read%';
-- 命中率 = Innodb_buffer_pool_read_requests / (Innodb_buffer_pool_read_requests + Innodb_buffer_pool_reads)

-- 慢查询统计
SHOW GLOBAL STATUS LIKE 'Slow_queries';

-- 锁等待
SHOW ENGINE INNODB STATUS\G
```

## 性能诊断工具

```bash
# 1. mysqldumpslow - 慢查询分析
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

# 2. pt-query-digest - Percona Toolkit（推荐）
pt-query-digest /var/log/mysql/slow.log

# 3. mysqltuner - 配置建议
wget http://mysqltuner.pl/ -O mysqltuner.pl
perl mysqltuner.pl

# 4. innotop - 实时监控
innotop
```

## 分区表优化（大表）

```sql
-- 按日期分区（适合日志表）
CREATE TABLE logs (
    id BIGINT UNSIGNED AUTO_INCREMENT,
    message TEXT,
    created_at DATETIME NOT NULL,
    PRIMARY KEY (id, created_at)
)
PARTITION BY RANGE (YEAR(created_at) * 100 + MONTH(created_at)) (
    PARTITION p202601 VALUES LESS THAN (202602),
    PARTITION p202602 VALUES LESS THAN (202603),
    PARTITION p202603 VALUES LESS THAN (202604),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

## 扩展阅读

- [MySQL Performance Blog](https://www.percona.com/blog/)
- [MySQL 8.0 性能调优文档](https://dev.mysql.com/doc/refman/8.0/en/optimization.html)
- [高性能 MySQL（第4版）](https://www.oreilly.com/library/view/high-performance-mysql/9781492080503/)
