---
id: 1308
title: Performance Optimization Workflow
description: 性能优化系统化流程 - 测量、分析、优化、验证
globs: ['**/*']
priority: medium
tags: [performance, optimization, workflow, methodology]
version: 1.0.0
author: Turbo AI Rules
lastUpdated: 2026-01-21
---

# 性能优化工作流

## 何时使用此技能

**必须优化**:
- 用户报告明显慢/卡顿
- 超过性能 SLA（如响应时间 >2s）
- 资源成本过高

**建议优化**:
- 预期流量增长 >3×
- 上线前性能基准测试
- 监控发现性能下降趋势

**不应优化**:
- 无具体性能问题
- "感觉可能会慢"
- 过早优化

---

## 核心原则

> "过早优化是万恶之源" —— Donald Knuth

✅ **先测量，再优化**  
✅ **优化瓶颈，非全部代码**  
✅ **每次优化后重新测量**  
✅ **权衡可读性与性能**

---

## 优化流程

### 步骤 1: 建立基准

**决策点**: 现在有多慢？目标是多快？

**行动**:
- 记录当前性能指标（响应时间、吞吐量、资源使用）
- 定义目标（如：P95 响应 <500ms）
- 确定测试场景（真实用户行为）

**工具选择**:
- Web: Lighthouse, WebPageTest
- API: ab, wrk, k6
- 数据库: EXPLAIN ANALYZE
- 后端: profiler (cProfile, perf)

**输出**: 基准报告 + 优化目标

---

### 步骤 2: 找到瓶颈

**决策点**: 最慢的是哪部分？

**分析维度**:

| 层级 | 检查项 | 工具 |
|------|--------|------|
| 网络 | 请求数量、传输大小 | DevTools Network |
| 前端 | 渲染时间、JS 执行 | DevTools Performance |
| 后端 | 函数耗时分布 | Profiler |
| 数据库 | 查询时间、索引使用 | Query Analyzer |
| 基础设施 | CPU、内存、I/O | 监控系统 |

**80/20 法则**:
- 通常 20% 的代码占 80% 的时间
- 找到并优化这 20%

---

### 步骤 3: 制定方案

**常见性能模式**:

| 问题模式 | 典型方案 |
|----------|----------|
| 重复计算 | 缓存、记忆化 |
| N+1 查询 | 批量加载、JOIN |
| 大数据集处理 | 分页、流式处理 |
| 阻塞 I/O | 异步、并发 |
| 未压缩资源 | Gzip、图片优化 |
| 无索引查询 | 添加数据库索引 |

**决策矩阵**:

| 方案 | 效果 | 复杂度 | 风险 | 优先级 |
|------|------|--------|------|--------|
| 添加索引 | 高 | 低 | 低 | P0 |
| 缓存结果 | 高 | 中 | 中 | P1 |
| 重构算法 | 高 | 高 | 高 | P2 |

---

### 步骤 4: 小步实施

**原则**: 一次优化一处

**流程**:
1. 实施单个优化
2. 运行性能测试
3. 对比基准数据
4. 提交（如有提升）或回滚（无效果）
5. 重复

**决策点**: 优化有效吗？
- 提升 >20% → 保留
- 提升 <5% → 回滚（不值得增加复杂度）
- 5-20% → 视情况决定

---

### 步骤 5: 验证与监控

**验证**:
- [ ] 性能达到目标
- [ ] 功能无回归
- [ ] 边界情况测试
- [ ] 生产环境验证

**持续监控**:
- 设置性能报警（响应时间、错误率）
- 定期性能基准测试
- 追踪性能趋势

---

## 优化技巧库

### 前端优化

**快速见效**:
- 代码分割（按路由）
- 图片懒加载
- 字体子集化
- Gzip/Brotli 压缩

**进阶优化**:
- 虚拟列表（大列表）
- Web Workers（CPU 密集）
- Service Worker（离线缓存）
- CDN（静态资源）

---

### 后端优化

**数据库层**:
- 添加索引（最常见且有效）
- 查询优化（避免 SELECT *）
- 连接池
- 读写分离

**应用层**:
- 缓存（Redis、Memcached）
- 异步处理（队列）
- 批量操作
- 算法优化（O(n²) → O(n log n)）

---

## 常见陷阱

| 陷阱 | 后果 | 应对 |
|------|------|------|
| 无测量盲目优化 | 浪费时间在非瓶颈 | 先 profile 后优化 |
| 过早优化 | 代码复杂难维护 | 先保证正确性 |
| 微优化 | 花 2h 省 5ms | 关注大头 |
| 忽视可读性 | 后续维护困难 | 权衡取舍，注释优化原因 |
| 本地测试 | 生产环境不同 | 生产数据量测试 |

---

## 性能目标指南

### Web 应用

| 指标 | 目标 | 优秀 |
|------|------|------|
| 首次内容绘制 (FCP) | <1.8s | <1s |
| 最大内容绘制 (LCP) | <2.5s | <1.5s |
| 首次输入延迟 (FID) | <100ms | <50ms |
| 累积布局偏移 (CLS) | <0.1 | <0.05 |

### API

| 指标 | 目标 |
|------|------|
| P50 响应时间 | <200ms |
| P95 响应时间 | <500ms |
| P99 响应时间 | <1s |
| 错误率 | <0.1% |

---

## 优化检查清单

**开始前**:
- [ ] 建立性能基准
- [ ] 识别瓶颈
- [ ] 明确优化目标
- [ ] 准备回滚计划

**过程中**:
- [ ] 一次优化一处
- [ ] 每次测量验证
- [ ] 记录优化效果
- [ ] 保持功能正确

**完成后**:
- [ ] 性能达标
- [ ] 测试通过
- [ ] 部署监控
- [ ] 文档记录优化点

---

## 何时停止优化

**停止信号**:
- ✅ 达到性能目标
- ⏱️ 投入产出比下降（花 1 天仅提升 2%）
- 🏗️ 需要架构级改造（单独项目）
- 📊 遇到外部瓶颈（第三方 API）

**记录遗留问题**:
```markdown
## 进一步优化空间
- [ ] 数据库分库分表（预估提升 50%，需 2 周）
- [ ] 引入消息队列（削峰填谷，需架构改造）
- [ ] CDN 加速（成本增加 $X/月）
```
