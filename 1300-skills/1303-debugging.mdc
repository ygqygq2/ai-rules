---
id: 1303
title: Debugging Skills
description: Effective debugging techniques and strategies
globs: ['**/*']
priority: high
tags: [debugging, skills, troubleshooting, problem-solving]
version: 1.0.0
author: Turbo AI Rules
lastUpdated: 2025-12-18
---

# Debugging Skills

## Systematic Approach

### 1. Reproduce the Issue

- Document exact steps to reproduce
- Identify environmental factors (OS, browser, dependencies)
- Create minimal reproduction case
- Verify issue exists in clean environment

### 2. Gather Information

```typescript
// Add strategic logging
console.log('Input:', input);
console.log('State before:', state);
console.log('State after:', newState);
console.log('Stack trace:', new Error().stack);

// Use debugger statements
function problematicFunction(data: any) {
  debugger; // Execution will pause here
  return processData(data);
}
```

### 3. Form Hypothesis

- What could cause this behavior?
- What changed recently?
- What assumptions am I making?
- What are the data flows?

### 4. Test and Validate

- Test one change at a time
- Use binary search for regression (git bisect)
- Validate assumptions with assertions
- Document findings

## Debugging Tools

### Browser DevTools

```javascript
// Console API
console.log('Basic logging');
console.table([{ name: 'Alice', age: 30 }]);
console.time('operation');
// ... code ...
console.timeEnd('operation');
console.trace('Call stack');

// Breakpoints
// - Line breakpoints
// - Conditional breakpoints: `x > 100`
// - Logpoints: Non-breaking console.log

// Network tab
// - Check request/response
// - Monitor timing
// - Inspect headers and payloads
```

### VS Code Debugger

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug TypeScript",
      "program": "${workspaceFolder}/src/index.ts",
      "preLaunchTask": "npm: build",
      "sourceMaps": true,
      "outFiles": ["${workspaceFolder}/dist/**/*.js"]
    }
  ]
}
```

### Command Line Tools

```bash
# Node.js debugging
node --inspect-brk index.js

# Memory profiling
node --inspect --heap-prof index.js

# Python debugging
python -m pdb script.py

# Git bisect for regression
git bisect start
git bisect bad HEAD
git bisect good v1.0.0
# Test each commit
git bisect good/bad
git bisect reset
```

## Common Debugging Scenarios

### Memory Leaks

```typescript
// Check for detached DOM nodes
// - Use Chrome DevTools Memory profiler
// - Take heap snapshots
// - Compare snapshots to find retained objects

// Common causes:
// 1. Event listeners not removed
window.addEventListener('resize', handler);
// Later: window.removeEventListener('resize', handler);

// 2. Timers not cleared
const timerId = setInterval(fn, 1000);
// Later: clearInterval(timerId);

// 3. Closures holding references
function createHandler() {
  const largeData = new Array(1000000);
  return () => {
    // largeData is kept in memory
    console.log(largeData.length);
  };
}
```

### Race Conditions

```typescript
// Add synchronization
let isProcessing = false;

async function handleClick() {
  if (isProcessing) {
    console.warn('Already processing');
    return;
  }

  isProcessing = true;
  try {
    await processData();
  } finally {
    isProcessing = false;
  }
}

// Use Promise.all for concurrent operations
await Promise.all([fetchUserData(), fetchSettings(), fetchPermissions()]);
```

### Type Errors

```typescript
// Add runtime validation
function processUser(user: unknown) {
  if (!isUser(user)) {
    throw new TypeError('Invalid user object');
  }
  // user is User type here
  return user.name;
}

function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'name' in obj &&
    typeof obj.name === 'string'
  );
}
```

## Best Practices

### 1. Write Debuggable Code

```typescript
// Good: Clear, debuggable
function processOrders(orders: Order[]): ProcessedOrder[] {
  const validOrders = validateOrders(orders);
  const enrichedOrders = enrichOrders(validOrders);
  const sortedOrders = sortOrders(enrichedOrders);
  return sortedOrders;
}

// Bad: Hard to debug
function processOrders(orders: Order[]): ProcessedOrder[] {
  return sortOrders(enrichOrders(validateOrders(orders)));
}
```

### 2. Add Assertions

```typescript
function divide(a: number, b: number): number {
  console.assert(b !== 0, 'Division by zero');
  console.assert(isFinite(a) && isFinite(b), 'Invalid numbers');
  return a / b;
}
```

### 3. Use Error Boundaries

```typescript
// React error boundary
class ErrorBoundary extends React.Component {
  componentDidCatch(error: Error, info: any) {
    console.error('Error caught:', error);
    console.error('Component stack:', info.componentStack);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }
    return this.props.children;
  }
}
```

### 4. Structured Logging

```typescript
import { Logger } from '@ygqygq2/vscode-log';

const logger = new Logger('MyModule');

function processData(data: any) {
  logger.info('Processing started', {
    dataSize: data.length,
    timestamp: Date.now(),
  });

  try {
    const result = transform(data);
    logger.info('Processing completed', {
      resultSize: result.length,
    });
    return result;
  } catch (error) {
    logger.error('Processing failed', {
      error: error.message,
      stack: error.stack,
      data: JSON.stringify(data).slice(0, 100),
    });
    throw error;
  }
}
```

## Advanced Techniques

### Performance Debugging

```typescript
// Use Performance API
performance.mark('start-operation');
await expensiveOperation();
performance.mark('end-operation');
performance.measure('operation-time', 'start-operation', 'end-operation');

const measures = performance.getEntriesByType('measure');
console.log('Duration:', measures[0].duration);
```

### Network Debugging

```typescript
// Add request interceptor
async function fetchWithLogging(url: string, options?: RequestInit) {
  const requestId = Math.random().toString(36);
  console.log(`[${requestId}] Request:`, url, options);

  const start = performance.now();
  try {
    const response = await fetch(url, options);
    const duration = performance.now() - start;
    console.log(`[${requestId}] Response:`, {
      status: response.status,
      duration: `${duration}ms`,
    });
    return response;
  } catch (error) {
    console.error(`[${requestId}] Error:`, error);
    throw error;
  }
}
```

## Resources

- Chrome DevTools Documentation
- VS Code Debugging Guide
- Node.js Debugging Guide
- Performance profiling tools
